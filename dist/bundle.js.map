{"version":3,"sources":["webpack:///webpack/bootstrap fb210fd6c416742dd302","webpack:///./ts/main.ts","webpack:///./ts/Raytracer.ts","webpack:///./ts/Vector.ts","webpack:///./ts/Quaternion.ts","webpack:///./ts/Camera.ts","webpack:///./ts/Shaders.ts","webpack:///./ts/Light.ts","webpack:///./ts/Sphere.ts"],"names":[],"mappings":"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","file":"./dist/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap fb210fd6c416742dd302\n **/","/*\r\n\r\nWebGL TypeScript Raytracer\r\n--------------------------\r\nAuthor: Dylan Cutler\r\n--------------------\r\n\r\nMain program\r\n\r\n*/\r\n\r\nimport Raytracer from \"./Raytracer\";\r\nimport Vector from \"./Vector\";\r\nimport Light from \"./Light\";\r\nimport Sphere from \"./Sphere\";\r\n\r\nfunction main(): void {\r\n  let canvas: HTMLCanvasElement;\r\n  let raytracer: Raytracer;\r\n\r\n  canvas = document.createElement(\"canvas\");\r\n  canvas.width = window.innerWidth;\r\n  canvas.height = window.innerHeight;\r\n  canvas.style.position = 'fixed'\r\n  canvas.style.left = '0px'; canvas.style.top = '0px';\r\n  document.body.appendChild(canvas);\r\n  raytracer = new Raytracer(canvas);\r\n  initAnimatedScene(raytracer);\r\n}\r\n\r\nwindow.onload = (event: Event): void => main();\r\n\r\n/***** Create animated scene *****/\r\n\r\nfunction initAnimatedScene(raytracer: Raytracer) {\r\n  raytracer.setLookAt(-1, 2, 15, 0, 5, 0);\r\n  raytracer.Animate = true;\r\n  raytracer.lights.push(\r\n    new Light({ pos: new Vector(0, 8, 8), color: new Vector(0.3, 0.5, 0.3), intensity: 10 }),\r\n    new Light({ pos: new Vector(6, 5, 10), color: new Vector(1, 0.7, 0.5), intensity: 10 }),\r\n    new Light({ pos: new Vector(-5, 1, 2), color: new Vector(0.5, 0.5, 1), intensity: 8 })\r\n  );\r\n  raytracer.spheres.push(\r\n    new Sphere({\r\n      pos: new Vector(0, 0.7, 0),\r\n      diffuse: new Vector(0.9, 0.5, 0.3),\r\n      specular: new Vector(1, 1, 1),\r\n      radius: 0.5,\r\n      shininess: 500,\r\n      refractiveIndex: 2.6,\r\n      opacity: 0.7\r\n    }),\r\n    new Sphere({\r\n      pos: new Vector(0.6, 0.7, 0),\r\n      diffuse: new Vector(0.7, 0.3, 0.3),\r\n      specular: new Vector(1, 1, 1),\r\n      radius: 0.07,\r\n      shininess: 500,\r\n      refractiveIndex: 2.4,\r\n      opacity: 0.8\r\n    }),\r\n    new Sphere({\r\n      pos: new Vector(1.3, 0.7, 0),\r\n      diffuse: new Vector(0.3, 0.6, 0.8),\r\n      specular: new Vector(1, 1, 1),\r\n      radius: 0.15,\r\n      shininess: 500,\r\n      refractiveIndex: 2.5,\r\n      opacity: 0.7\r\n    }),\r\n    new Sphere({\r\n      pos: new Vector(1.32, 0.9, 0),\r\n      diffuse: new Vector(1, 1, 1),\r\n      specular: new Vector(1, 1, 1),\r\n      radius: 0.04,\r\n      shininess: 500,\r\n      refractiveIndex: 2.5,\r\n      opacity: 0.6\r\n    }),\r\n    new Sphere({\r\n      pos: new Vector(1.75, 0, 0),\r\n      diffuse: new Vector(0.3, 0.3, 1),\r\n      specular: new Vector(1, 1, 1),\r\n      radius: 0.3,\r\n      refractiveIndex: 2.4,\r\n      opacity: 0.4\r\n    })\r\n  )\r\n\r\n  function animate(raytracer: Raytracer): void {\r\n    let time: number;\r\n    let pos1: Vector;\r\n    let pos2: Vector;\r\n    let pos3: Vector;\r\n    let pos4: Vector;\r\n    time = new Date().getTime();\r\n    pos1 = new Vector(0.7, 0.7, 0);\r\n    pos1 = Vector.rotate(pos1, time/723, new Vector(0, 1, 0));\r\n    raytracer.spheres[1].position = pos1;\r\n    pos2 = new Vector(1, 0.7, 0);\r\n    pos2 = Vector.rotate(pos2, time/1000, new Vector(0, 1, 0));\r\n    raytracer.spheres[2].position = pos2;\r\n    pos3 = new Vector(-0.3, 0.15, 0);\r\n    pos3 = Vector.rotate(pos3, time/600, new Vector(1, 2, 0));\r\n    pos3 = Vector.add(pos2, pos3);\r\n    raytracer.spheres[3].position = pos3;\r\n    pos4 = new Vector(1.75, 0.7, 0);\r\n    pos4 = Vector.rotate(pos4, time/1870, new Vector(0, 1, 0));\r\n    raytracer.spheres[4].position = pos4;\r\n  }\r\n  setTimeout(() => { raytracer.render(animate) }, 100);\r\n}\r\n\r\n\r\n/***** Create static scene *****/\r\n\r\nfunction initStaticScene(raytracer: Raytracer) {\r\n  raytracer.setLookAt(-1, 2, 15, 0, 5, 0);\r\n  raytracer.Animate = false;\r\n  raytracer.lights.push(\r\n    new Light({ pos: new Vector(0, 8, 8), color: new Vector(0.3, 0.5, 0.3), intensity: 10 }),\r\n    new Light({ pos: new Vector(6, 5, 10), color: new Vector(1, 0.7, 0.5), intensity: 10 }),\r\n    new Light({ pos: new Vector(-5, 1, 2), color: new Vector(0.5, 0.5, 1), intensity: 8 })\r\n  );\r\n  raytracer.spheres.push(\r\n    new Sphere({\r\n      pos: new Vector(0.5, 0.5, 1.5),\r\n      diffuse: new Vector(0.3, 0.5, 0.7),\r\n      specular: new Vector(1, 1, 1),\r\n      radius: 0.3,\r\n      shininess: 500,\r\n      refractiveIndex: 2.6,\r\n      opacity: 0.5\r\n    }),\r\n    new Sphere({\r\n      pos: new Vector(-0.3, 0.5, -1),\r\n      diffuse: new Vector(1, 0.5, 0.3),\r\n      radius: 0.5,\r\n      shininess: 50,\r\n      refractiveIndex: 2.4,\r\n      opacity: 0.8\r\n    }),\r\n    new Sphere({\r\n      pos: new Vector(1.75, 0.8, -5),\r\n      diffuse: new Vector(0.3, 0.7, 0.3),\r\n      specular: new Vector(1, 1, 1),\r\n      radius: 0.8,\r\n      shininess: 500,\r\n      refractiveIndex: 2,\r\n      opacity: 0.4\r\n    }),\r\n    new Sphere({\r\n      pos: new Vector(-0.8, 1, 4),\r\n      diffuse: new Vector(1, 1, 1),\r\n      radius: 0.2,\r\n      shininess: 1000,\r\n      refractiveIndex: 2.6,\r\n      opacity: 0.3\r\n    })\r\n  );\r\n\r\n  function animate(raytracer: Raytracer): void {}\r\n  setTimeout(() => { raytracer.render(animate); }, 100);\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/main.ts\n **/","/*\r\n\r\nWebGL Raytracer\r\n---------------\r\n\r\nScene object:\r\n- Initializes instance of WebGL\r\n- Calls functions for WebGL to render\r\n- Initializes the shaders using initShaders()\r\n- Sends information about the camera to the GPU\r\n- Renders the scene\r\n\r\n*/\r\n\r\nimport Vector from \"./Vector\";\r\nimport Camera from \"./Camera\";\r\nimport initShaders from \"./Shaders\";\r\nimport Light from \"./Light\";\r\nimport Sphere from \"./Sphere\";\r\n\r\nexport default class Raytracer {\r\n\r\n  private ASPECT_RATIO: number;\r\n  private gl: WebGLRenderingContext;\r\n  private shaderProgram: WebGLProgram;\r\n  private camera: Camera;\r\n\r\n  public lights: Light[];\r\n  public spheres: Sphere[];\r\n  public Animate: boolean;\r\n\r\n  /*\r\n  * @class Raytracer\r\n  * @constructor\r\n  */\r\n  constructor(canvas: HTMLCanvasElement) {\r\n    this.ASPECT_RATIO = canvas.width / canvas.height;\r\n    // Initialzing WebGL\r\n    this.gl = <WebGLRenderingContext>\r\n      canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\n    this.gl.viewport(0, 0, canvas.width, canvas.height);\r\n    this.gl.clearColor(0, 0, 0, 1);\r\n    this.gl.clearDepth(1);\r\n    // Initializing shaders\r\n    this.shaderProgram = initShaders(this.gl);\r\n    if( this.shaderProgram === null ) {\r\n      throw new Error(\"Could not compile shaders. See error message for details.\");\r\n    }\r\n    // Initializing buffers\r\n    this.initBuffers();\r\n    // Setting camera to null\r\n    this.camera = null;\r\n    // Initializing lights array\r\n    this.lights = [];\r\n    // Initializing spheres array\r\n    this.spheres = [];\r\n    // Initializing flag for whether the raytracer animates\r\n    this.Animate = false;\r\n  }\r\n\r\n  /*\r\n  * This method initializes the vertex buffers, input is aspect ratio\r\n  *\r\n  * @class Raytracer\r\n  * @method initBuffers\r\n  */\r\n  private initBuffers(): void {\r\n    let aWindowPosition: number;\r\n    let aPosition: number;\r\n    let vertices: number[];\r\n    let windowBuffer: WebGLBuffer;\r\n    let positionBuffer: WebGLBuffer;\r\n\r\n    // Buffer for the vertices of the window\r\n    aWindowPosition = this.gl.getAttribLocation(this.shaderProgram, 'aWindowPosition');\r\n    this.gl.enableVertexAttribArray(aWindowPosition);\r\n\r\n    aPosition = this.gl.getAttribLocation(this.shaderProgram, 'aPosition');\r\n    this.gl.enableVertexAttribArray(aPosition);\r\n\r\n    vertices = [\r\n      -1., 1.,\r\n      -1., -1.,\r\n      1., 1.,\r\n      1., -1.\r\n    ];\r\n\r\n    windowBuffer = this.gl.createBuffer();\r\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, windowBuffer);\r\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);\r\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, windowBuffer);\r\n    this.gl.vertexAttribPointer(aWindowPosition, 2, this.gl.FLOAT, false, 0, 0);\r\n\r\n    positionBuffer = this.gl.createBuffer();\r\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\r\n    this.gl.vertexAttribPointer(aPosition, 3, this.gl.FLOAT, false, 0, 0);\r\n  }\r\n\r\n  /*\r\n  * This method sets position and lookAt vectors of the camera\r\n  *\r\n  * @class Raycaster\r\n  * @method setLookAt\r\n  */\r\n  public setLookAt( eyeX: number, eyeY: number, eyeZ: number,\r\n                     atX: number,  atY: number,  atZ: number ): void\r\n  {\r\n    this.camera = new Camera(new Vector(eyeX, eyeY, eyeZ),\r\n                             new Vector( atX,  atY,  atZ));\r\n  }\r\n\r\n  /*\r\n  * This method renders the scene in WebGL\r\n  *\r\n  * @class Raycaster\r\n  * @method render\r\n  */\r\n  public render(animate: (raytracer: Raytracer) => void): void {\r\n    // Executes callback for each draw\r\n    animate(this);\r\n\r\n    const AspRat: number = this.ASPECT_RATIO;\r\n    let cameraPosition: WebGLUniformLocation;\r\n    let lightUniform: WebGLUniformLocation;\r\n    let sphereUniform: WebGLUniformLocation;\r\n    let cameraTopLeft: Vector;\r\n    let cameraBottomLeft: Vector;\r\n    let cameraTopRight: Vector;\r\n    let cameraBottomRight: Vector;\r\n    let corners: number[];\r\n    let aPosition: number;\r\n\r\n    // Clear last rendered frame\r\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\r\n\r\n    // Passing camera position to the shader\r\n    cameraPosition = this.gl.getUniformLocation(this.shaderProgram, 'cameraPos');\r\n    this.gl.uniform3fv(cameraPosition, new Float32Array(Vector.push(this.camera.pos, [])));\r\n\r\n    // Passing lights to the shader\r\n    lightUniform = this.gl.getUniformLocation(this.shaderProgram, 'numLights');\r\n    this.gl.uniform1i(lightUniform, this.lights.length);\r\n    this.lights.map((currLight: Light, index: number) => {\r\n      // Sending positions\r\n      lightUniform = this.gl.getUniformLocation(this.shaderProgram, 'lightPos['+index+']');\r\n      this.gl.uniform3fv(lightUniform, new Float32Array(Vector.push(currLight.position, [])));\r\n      // Sending colors\r\n      lightUniform = this.gl.getUniformLocation(this.shaderProgram, 'lightCol['+index+']');\r\n      this.gl.uniform3fv(lightUniform, new Float32Array(Vector.push(currLight.color, [])));\r\n      // Sending intensities\r\n      lightUniform = this.gl.getUniformLocation(this.shaderProgram, 'intensities['+index+']');\r\n      this.gl.uniform1f(lightUniform, currLight.intensity);\r\n    });\r\n\r\n    // Passing spheres to the shader\r\n    sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'numSpheres');\r\n    this.gl.uniform1i(sphereUniform, this.spheres.length);\r\n    this.spheres.map((currSphere: Sphere, index: number) => {\r\n      // Sending positions\r\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'spherePos['+index+']');\r\n      this.gl.uniform3fv(sphereUniform, new Float32Array(Vector.push(currSphere.position, [])));\r\n      // Sending radius of sphere\r\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereRadius['+index+']');\r\n      this.gl.uniform1f(sphereUniform, currSphere.radius);\r\n      // Sending diffuse colors\r\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereDiff['+index+']');\r\n      this.gl.uniform3fv(sphereUniform, new Float32Array(Vector.push(currSphere.diffuse, [])));\r\n      // Sending specular colors\r\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereSpec['+index+']');\r\n      this.gl.uniform3fv(sphereUniform, new Float32Array(Vector.push(currSphere.specular, [])));\r\n      // Sending Phong exponent to the shader\r\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereShininess['+index+']');\r\n      this.gl.uniform1f(sphereUniform, currSphere.shininess);\r\n      // Sending refractive index to the shader\r\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereRefrIndex['+index+']');\r\n      this.gl.uniform1f(sphereUniform, currSphere.refractiveIndex);\r\n      // Sending sphere's opacity to the shader\r\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereOpacity['+index+']');\r\n      this.gl.uniform1f(sphereUniform, currSphere.opacity);\r\n    });\r\n\r\n    // Get camera corners\r\n    corners = [];\r\n    cameraTopLeft = Vector.add(\r\n      this.camera.forward,\r\n      Vector.subtract(this.camera.up, Vector.scale(AspRat, this.camera.right))\r\n    );\r\n    cameraBottomLeft = Vector.subtract(\r\n      this.camera.forward,\r\n      Vector.add(this.camera.up, Vector.scale(AspRat, this.camera.right))\r\n    );\r\n    cameraTopRight = Vector.add(\r\n      this.camera.forward,\r\n      Vector.add(this.camera.up, Vector.scale(AspRat, this.camera.right))\r\n    );\r\n    cameraBottomRight = Vector.add(\r\n      this.camera.forward,\r\n      Vector.subtract(Vector.scale(AspRat, this.camera.right), this.camera.up)\r\n    );\r\n    Vector.push(cameraTopLeft, corners);\r\n    Vector.push(cameraBottomLeft, corners);\r\n    Vector.push(cameraTopRight, corners);\r\n    Vector.push(cameraBottomRight, corners);\r\n\r\n    // Passing corners to the shader via the array buffer\r\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(corners), this.gl.STATIC_DRAW);\r\n\r\n    // Draw new frame\r\n    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\r\n\r\n    // Render loop\r\n    if( this.Animate ) window.requestAnimationFrame(() => { this.render(animate); });\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Raytracer.ts\n **/","/*\r\n\r\nWebGL Raytracer\r\n---------------\r\n\r\nVector object\r\n- vector operations\r\n- push components to an array\r\n\r\n*/\r\n\r\nimport Quaternion from \"./Quaternion\";\r\n\r\nexport default class Vector {\r\n  constructor(public x: number,\r\n              public y: number,\r\n              public z: number) {}\r\n\r\n  public set(x: number, y: number, z: number) {\r\n    this.x = x; this.y = y; this.z = z;\r\n  }\r\n\r\n  static scale(k: number, v: Vector): Vector {\r\n    return new Vector(k*v.x, k*v.y, k*v.z)\r\n  }\r\n  static add(v1: Vector, v2: Vector): Vector {\r\n    return new Vector(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);\r\n  }\r\n  static subtract(v1: Vector, v2: Vector): Vector {\r\n    return new Vector(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);\r\n  }\r\n  static mag(v: Vector): number {\r\n    return Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);\r\n  }\r\n  static normalize(v: Vector): Vector {\r\n    let mag: number;\r\n    let div: number;\r\n    mag = Vector.mag(v);\r\n    if(mag === 0) {\r\n      console.log('Cannot normalize zero vector');\r\n      return null;\r\n    }\r\n    div = 1/mag;\r\n    return Vector.scale(div, v);\r\n  }\r\n  static cross(v1: Vector, v2: Vector): Vector {\r\n    return new Vector(v1.y * v2.z - v1.z * v2.y,\r\n                      v1.z * v2.x - v1.x * v2.z,\r\n                      v1.x * v2.y - v1.y * v2.x);\r\n  }\r\n  static rotate(v: Vector, theta: number, axis: Vector): Vector {\r\n    let p: Quaternion;\r\n    let u: Vector;\r\n    let q: Quaternion;\r\n    p = new Quaternion(0, v.x, v.y, v.z);\r\n    u = Vector.scale(Math.sin(theta / 2), Vector.normalize(axis));\r\n    q = new Quaternion(Math.cos(theta / 2), u.x, u.y, u.z);\r\n    p = Quaternion.multiply(p, q.conjugate());\r\n    p = Quaternion.multiply(q, p);\r\n    return new Vector(p.i, p.j, p.k);\r\n  }\r\n  static push(v: Vector, array: number[]): number[] {\r\n    array.push(v.x, v.y, v.z);\r\n    return array;\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Vector.ts\n **/","/*\r\n\r\nWebGL Raytacer\r\n--------------\r\n\r\nQuaternion object\r\n- Contains mathematical operations for quaternions\r\n\r\n*/\r\n\r\nexport default class Quaternion {\r\n  constructor( public r: number,\r\n               public i: number,\r\n               public j: number,\r\n               public k: number ) {}\r\n  public conjugate(): Quaternion {\r\n    return new Quaternion(this.r, -this.i, -this.j, -this.k);\r\n  }\r\n  static multiply(q1: Quaternion, q2: Quaternion): Quaternion {\r\n    return new Quaternion( q1.r*q1.r - q1.i*q2.i - q1.j*q2.j - q1.k*q2.k,\r\n                           q1.r*q2.i + q1.i*q2.r + q1.j*q2.k - q1.k*q2.j,\r\n                           q1.r*q2.j - q1.i*q2.k + q1.j*q2.r + q1.k*q2.i,\r\n                           q1.r*q2.k + q1.i*q2.j - q1.j*q2.i + q1.k*q2.r );\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Quaternion.ts\n **/","/*\r\n\r\nWebGL Raytracer\r\n---------------\r\n\r\nCamera object:\r\n- has public vector classes for raytracer\r\n\r\n*/\r\n\r\nimport Vector from \"./Vector\";\r\n\r\nexport default class Camera {\r\n  public forward: Vector;\r\n  public right: Vector;\r\n  public up: Vector;\r\n\r\n  constructor(public pos: Vector, lookAt: Vector) {\r\n    let down: Vector;\r\n    down = new Vector(0, -1, 0);\r\n    this.forward = Vector.normalize(Vector.subtract(lookAt, this.pos));\r\n    this.right = Vector.normalize(Vector.cross(down, this.forward));\r\n    this.up = Vector.normalize(Vector.cross(this.right, this.forward));\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Camera.ts\n **/","/*\r\n\r\nWebGL Raytracer\r\n---------------\r\n\r\nShaders module:\r\n- contains source for vertex and fragment shaders\r\n- contains function to get shader program from source and compiles them\r\n- exports a function which initializes the shaders and returns the shader\r\n  program\r\n\r\n*/\r\n\r\n/****************************************************/\r\n\r\n/*\r\n* SHADER SOURCE CODE\r\n*/\r\n\r\nlet VERTEX_SHADER: string;\r\nlet FRAGMENT_SHADER: string;\r\n\r\n/* VERTEX SHADER */\r\n\r\nVERTEX_SHADER = `\r\n  precision mediump float;\r\n\r\n  attribute vec2 aWindowPosition;\r\n  attribute vec3 aPosition;\r\n\r\n  varying vec3 vPosition;\r\n\r\n  void main() {\r\n    gl_Position = vec4(aWindowPosition, 1., 1.);\r\n    vPosition = aPosition;\r\n  }\r\n`;\r\n\r\n/* FRAGMENT SHADER */\r\n\r\nFRAGMENT_SHADER = `\r\n  precision mediump float;\r\n\r\n  varying vec3 vPosition;\r\n\r\n  uniform vec3 cameraPos;\r\n  uniform int numLights;\r\n  uniform vec3 lightPos[32];\r\n  uniform vec3 lightCol[32];\r\n  uniform float intensities[32];\r\n  uniform int numSpheres;\r\n  uniform vec3 spherePos[32];\r\n  uniform float sphereRadius[32];\r\n  uniform vec3 sphereDiff[32];\r\n  uniform vec3 sphereSpec[32];\r\n  uniform float sphereShininess[32];\r\n  uniform float sphereRefrIndex[32];\r\n  uniform float sphereOpacity[32];\r\n\r\n  const int numReflections = 3;\r\n\r\n  /***** INTERSECTION TESTS FOR GEOMETRIES *****/\r\n\r\n  /**\r\n  * Intersection test for a plane at y = 0\r\n  */\r\n  float intersectPlane(vec3 rayStart, vec3 rayDir) {\r\n    float dist;\r\n    float denom;\r\n\r\n    dist = -1.;\r\n    denom = dot(rayDir, vec3(0., 1., 0.));\r\n    if( denom < 0. ) {\r\n      dist = dot(-rayStart, vec3(0., 1., 0.)) / denom;\r\n    }\r\n\r\n    return dist;\r\n  }\r\n\r\n  /**\r\n  * Intersection test for spheres\r\n  */\r\n  float intersectSphere(vec3 rayStart, vec3 rayDir, vec3 center, float r) {\r\n    vec3 at;\r\n    float v;\r\n    float dist;\r\n    float disc;\r\n\r\n    at = center - rayStart;\r\n    v = dot(at, rayDir);\r\n    dist = -1.;\r\n    if( v >= 0. ) {\r\n      disc = r * r - ( dot(at, at) - v * v );\r\n      if( disc > 0. ) dist = v - sqrt(disc);\r\n    }\r\n    return dist;\r\n  }\r\n\r\n  /***** OPTICAL FUNCTIONS *****/\r\n\r\n  /**\r\n  * Test for shadow casting implements pyramid tracing to soften shadow edges\r\n  */\r\n  void testForShadow( inout bool inShadow[4],\r\n                        float distanceToLight,\r\n                        vec3 rayStart,\r\n                        vec3 rayDir,\r\n                        vec3 normal )\r\n  {\r\n    vec3 dx;\r\n    vec3 dy;\r\n    float r;\r\n\r\n    dx = cross(normal, rayDir);\r\n    if( length(dx) != 0. ) dx = normalize(dx);\r\n    dy = cross(rayDir, dx);\r\n    if( length(dy) != 0. ) dy = normalize(dy);\r\n    r = 0.01;\r\n\r\n    for( int j = 0; j < 4; j++ )\r\n    for( int i = 0; i < 32; i++ ) {\r\n      if( i >= numSpheres ) continue;\r\n\r\n      vec3 ds;\r\n      float dist;\r\n\r\n      if( j == 0 ){ ds = -dx - dy; }\r\n      else if( j == 1 ){ ds = dx - dy; }\r\n      else if( j == 2 ){ ds = dy - dx; }\r\n      else { ds = dy + dx; }\r\n      ds = r * normalize(ds);\r\n\r\n      dist = intersectSphere(rayStart, normalize(rayDir + ds), spherePos[i], sphereRadius[i]);\r\n      if( dist > 0. && dist < distanceToLight ) inShadow[j] = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Determine the reflectance of the sphere using its refractive index\r\n  * and the Fresnel equations\r\n  */\r\n  float determineReflectance(vec3 normal, vec3 rayDir, float refrIndex) {\r\n    float cosine_i;\r\n    float sine_i;\r\n    float theta_t;\r\n    float cosine_t;\r\n    float refl;\r\n\r\n    /* Snell's law to find the angle the transmitted ray makes with the normal */\r\n    cosine_i = dot(normalize(normal), normalize(-rayDir));\r\n    sine_i = length(cross( normalize(normal), normalize(-rayDir) ));\r\n    theta_t = asin( sine_i / refrIndex );\r\n    cosine_t = cos(theta_t);\r\n\r\n    /* Finding reflectance with Fresnel's equations */\r\n    refl = cosine_i - refrIndex * cosine_t;\r\n    refl /= cosine_i + refrIndex * cosine_t;\r\n    refl = pow(abs(refl), 2.);\r\n\r\n    return clamp(refl, 0., 1.);\r\n  }\r\n\r\n  /**\r\n  * Determine the direction of the transmitted light ray\r\n  */\r\n  void transmitRay( vec3 rayStart,\r\n                    vec3 rayDir,\r\n                    vec3 opticalAxis,\r\n                    float refrIndex,\r\n                    float radius,\r\n                    out vec3 outStart,\r\n                    out vec3 outDir )\r\n  {\r\n    vec3 normalAxis;\r\n    vec2 opticalVec;\r\n    mat2 Refr_1;\r\n    mat2 Refr_2;\r\n\r\n    /* Determining normal axis */\r\n    normalAxis = rayDir - (dot(rayDir, -opticalAxis) * opticalAxis);\r\n    if( length(normalAxis) != 0. ) normalAxis = normalize(normalAxis);\r\n\r\n    /* Defining quantities for matrix ray tracing */\r\n    opticalVec = vec2( 0., acos(dot(opticalAxis, -rayDir)) );\r\n    Refr_1 = mat2( 1., (1. - refrIndex)/(radius * refrIndex), 0., 1./refrIndex );\r\n    Refr_2 = mat2( 1., (refrIndex - 1.)/radius, 0., refrIndex );\r\n\r\n    /* First refraction */\r\n    opticalVec = Refr_1 * opticalVec;\n    /* Translation through medium of the sphere */\n    opticalVec.x += sin(opticalVec.y) * 2. * radius;\n\n    /* Determining the starting point of the outgoing ray */\n    outStart = rayStart - (cos(opticalVec.y) * opticalAxis) + (opticalVec.x * normalAxis);\r\n\r\n    /* Second refraction */\r\n    opticalVec = Refr_2 * opticalVec;\r\n\r\n    /* Determining the direction of the outgoing ray */\r\n    outDir = (-cos(opticalVec.y) * opticalAxis) + (sin(opticalVec.y) * normalAxis);\r\n  }\r\n\r\n  /***** COLORING FUNCTIONS *****/\r\n\r\n  /**\r\n  * Color fragment using Blinn-Phong global illumination model\r\n  */\r\n  vec3 getNaturalColor( vec3 pos,\r\n                        vec3 normal,\r\n                        vec3 viewDir,\r\n                        vec3 diffColor,\r\n                        vec3 specColor,\r\n                        float shininess )\r\n  {\r\n    vec3 color = vec3(0.);\r\n    for ( int i = 0; i < 32; i++ ) {\r\n      if( i >= numLights ) continue;\r\n\r\n      vec3 currPos;\r\n      vec3 currColor;\r\n      float intensity;\r\n      vec3 lightDir;\r\n      float distance;\r\n      bool isInShadow[4];\r\n      float lMax;\r\n      float sMax;\r\n      vec3 testColor;\r\n      float lambertian;\r\n      vec3 H;\r\n      float specular;\r\n\r\n      lightDir = normalize(lightPos[i] - pos);\r\n      distance = length(lightPos[i] - pos);\r\n\r\n      testForShadow(isInShadow, distance, pos, lightDir, normal);\r\n\r\n      lMax = 1.; sMax = 1.;\r\n\r\n      for( int j = 0; j < 4; j++ ) {\r\n        if( isInShadow[j] ) {\r\n          lMax -= 0.2;\r\n          sMax -= 0.2475;\r\n        }\r\n      }\r\n\r\n      lambertian = clamp(intensities[i] * dot(normal, lightDir) / distance, 0.0, lMax);\r\n\r\n      H = normalize(lightDir + viewDir);\r\n      specular = clamp(intensities[i] * pow(dot(normal, H), shininess) / distance / distance, 0.01, sMax);\r\n\r\n      color += (lambertian * diffColor + specular * specColor) * lightCol[i];\r\n    }\r\n    return color;\r\n  }\r\n\r\n  /**\r\n  * Get refracted color of non-opaque objects\r\n  */\r\n  vec3 getRefractedColor(vec3 refrStart, vec3 rayDir, vec3 opticalAxis, float refrIndex, float radius, float opacity) {\r\n    vec3 color;\r\n    vec3 rayStart_f;\r\n    vec3 rayDir_f;\r\n    float closestDist;\r\n    float dist;\r\n    vec3 pos;\r\n    vec3 normal;\r\n    vec3 diffCol;\r\n    vec3 specCol;\r\n    float phongExp;\r\n    float refl;\r\n    float index;\r\n\r\n    color = vec3(0.);\r\n    transmitRay(refrStart, rayDir, opticalAxis, refrIndex, radius, rayStart_f, rayDir_f);\r\n\r\n    closestDist = 100000.;\r\n\r\n    dist = intersectPlane(rayStart_f, rayDir_f);\r\n    if( dist > 0. ) {\r\n      closestDist = dist;\r\n      pos = dist * rayDir_f + rayStart_f;\r\n      normal = vec3(0., 1., 0.);\r\n      if( mod(floor(pos.x) + floor(pos.z), 2.) != 0. ) {\r\n        diffCol = vec3(0.9);\r\n        specCol = vec3(1.);\r\n        refl = determineReflectance(normal, rayDir_f, 1.05);\r\n      }\r\n      else {\r\n        diffCol = vec3(0.2, 0.2, 0.4);\r\n        specCol = vec3(0.4);\r\n        refl = determineReflectance(normal, rayDir_f, 1.2);\r\n      }\r\n    }\r\n\r\n    for( int i = 0; i < 32; i++ ) {\r\n      if( i >= numSpheres ) continue;\r\n\r\n      float distance;\r\n      distance = intersectSphere(rayStart_f, rayDir_f, spherePos[i], sphereRadius[i]);\r\n\r\n      if( distance > 0. && distance < closestDist ) {\r\n        dist = distance;\r\n        closestDist = distance;\r\n        pos = distance * rayDir_f + rayStart_f;\r\n        normal = normalize(pos - spherePos[i]);\r\n        diffCol = sphereDiff[i];\r\n        specCol = sphereSpec[i];\r\n        phongExp = sphereShininess[i];\r\n        index = sphereRefrIndex[i];\r\n        refl = determineReflectance(normal, rayDir_f, index);\r\n      }\r\n    }\r\n\r\n    if( dist > 0. ) {\r\n      color = getNaturalColor(pos, normal, -rayDir_f, diffCol, specCol, phongExp);\r\n      color *= opacity;\r\n    }\r\n\r\n    return color;\r\n  }\r\n\r\n  /**\r\n  * Get reflected color\r\n  */\r\n  vec3 getReflectedColor(vec3 reflStart, vec3 reflNormal, vec3 rayDir, float refl) {\r\n    const int MAX_DEPTH = 3;\r\n\r\n    vec3 color;\r\n    float closestDist;\r\n    vec3 reflDir;\r\n    float dist;\r\n    vec3 pos;\r\n    vec3 normal;\r\n    vec3 diffCol;\r\n    vec3 specCol;\r\n    float phongExp;\r\n    float opacity;\r\n    float index;\r\n    float radius;\r\n\r\n    color = vec3(0.);\r\n\r\n    for( int i = 0; i <= MAX_DEPTH; i++ ) {\r\n      float thisRefl = 1.;\r\n\r\n      closestDist = 100000.;\r\n      reflDir = reflect(rayDir, reflNormal);\r\n\r\n      dist = intersectPlane(reflStart, reflDir);\r\n      if( dist > 0. ) {\r\n        closestDist = dist;\r\n        pos = dist * reflDir + reflStart;\r\n        normal = vec3(0., 1., 0.);\r\n        if( mod(floor(pos.x) + floor(pos.z), 2.) != 0. ) {\r\n          diffCol = vec3(0.9);\r\n          specCol = vec3(1.);\r\n          if( i != 0 ) thisRefl = determineReflectance(normal, rayDir, 1.2);\r\n        }\r\n        else {\r\n          diffCol = vec3(0.4, 0.4, 0.6);\r\n          specCol = vec3(0.6);\r\n          if( i != 0 ) thisRefl = determineReflectance(normal, rayDir, 1.7);\r\n        }\r\n        phongExp = 250.;\r\n        opacity = 1.;\r\n      }\r\n\r\n      for( int i = 0; i < 32; i++ ) {\r\n        if( i >= numSpheres ) continue;\r\n\r\n        float distance;\r\n        distance = intersectSphere(reflStart, reflDir, spherePos[i], sphereRadius[i]);\r\n        if( distance >= 0. && distance < closestDist ) {\r\n          dist = distance;\r\n          closestDist = dist;\r\n          pos = dist * reflDir + reflStart;\r\n          normal = normalize(pos - spherePos[i]);\r\n          diffCol = sphereDiff[i];\r\n          specCol = sphereSpec[i];\r\n          phongExp = sphereShininess[i];\r\n          index = sphereRefrIndex[i];\r\n          if( i != 0 ) determineReflectance(normal, rayDir, index);\r\n          opacity = sphereOpacity[i];\r\n          radius = sphereRadius[i];\r\n        }\r\n      }\r\n\r\n      if( dist > 0. ) {\r\n        vec3 c = getNaturalColor(pos, normal, -reflDir, diffCol, specCol, phongExp);\r\n        refl *= thisRefl;\r\n        color += pow(refl, float(i+1)) * c;\r\n        if( opacity != 1. ) {\r\n          color *= opacity;\r\n          vec3 refrCol;\r\n          refrCol = getRefractedColor(pos, -reflDir, normal, index, radius, opacity);\r\n          refrCol *= 1. - opacity;\r\n          color += refrCol;\r\n        }\r\n\r\n        reflStart = pos;\r\n        reflNormal = normal;\r\n        rayDir = reflDir;\r\n      }\r\n      else break;\r\n    }\r\n\r\n    return color;\r\n  }\r\n\r\n  /***** MAIN PROGRAM *****/\r\n\r\n  /**\r\n  * Intersection test for the world\r\n  * returns a color vector\r\n  */\r\n  vec3 intersectWorld(vec3 rayStart, vec3 rayDir) {\r\n    vec3 color;\r\n    float closestDist;\r\n    float dist;\r\n    vec3 pos;\r\n    vec3 normal;\r\n    vec3 diffCol;\r\n    vec3 specCol;\r\n    float phongExp;\r\n    float refl;\r\n    float opacity;\r\n    float index;\r\n    float radius;\r\n\r\n\r\n    color = vec3(0.);\r\n    closestDist = 100000.;\r\n\r\n    dist = intersectPlane(rayStart, rayDir);\r\n    if( dist > 0. ) {\r\n      closestDist = dist;\r\n      pos = dist * rayDir + rayStart;\r\n      normal = vec3(0., 1., 0.);\r\n      if( mod(floor(pos.x) + floor(pos.z), 2.) != 0. ) {\r\n        diffCol = vec3(0.9);\r\n        specCol = vec3(1.);\r\n        refl = determineReflectance(normal, rayDir, 1.05);\r\n      }\r\n      else {\r\n        diffCol = vec3(0.2, 0.2, 0.4);\r\n        specCol = vec3(0.4);\r\n        refl = determineReflectance(normal, rayDir, 1.2);\r\n      }\r\n      phongExp = 250.;\r\n      opacity = 1.;\r\n    }\r\n\r\n    for( int i = 0; i < 32; i++ ) {\r\n      if( i >= numSpheres ) continue;\r\n\r\n      float distance;\r\n      distance = intersectSphere(rayStart, rayDir, spherePos[i], sphereRadius[i]);\r\n\r\n      if( distance > 0. && distance < closestDist ) {\r\n        dist = distance;\r\n        closestDist = distance;\r\n        pos = distance * rayDir + rayStart;\r\n        normal = normalize(pos - spherePos[i]);\r\n        diffCol = sphereDiff[i];\r\n        specCol = sphereSpec[i];\r\n        phongExp = sphereShininess[i];\r\n        index = sphereRefrIndex[i];\r\n        refl = determineReflectance(normal, rayDir, index);\r\n        opacity = sphereOpacity[i];\r\n        radius = sphereRadius[i];\r\n      }\r\n    }\r\n\r\n    if( dist > 0. ) {\r\n      color = getNaturalColor(pos, normal, -rayDir, diffCol, specCol, phongExp);\r\n      if( opacity != 1. ) {\r\n        color *= opacity;\r\n        vec3 refrCol;\r\n        refrCol = getRefractedColor(pos, rayDir, normal, index, radius, opacity);\r\n        refrCol *= 1. - opacity;\r\n        color += refrCol;\r\n      }\r\n      color += getReflectedColor(pos, normal, rayDir, refl);\r\n    }\r\n\r\n    return color;\r\n  }\r\n\r\n  /**\r\n  * Main function, just determines the direction of the initial ray and\r\n  * calls intersectWorld()\r\n  */\r\n  void main() {\r\n    vec3 cameraDir;\r\n    vec3 color;\r\n\r\n    cameraDir = normalize(vPosition - cameraPos);\r\n    color = intersectWorld(cameraPos, cameraDir);\r\n\r\n    gl_FragColor = vec4(color, 1.);\r\n  }\r\n`;\r\n\r\n/****************************************************/\r\n\r\n/*\r\n* This function loads the shader from the source code\r\n*/\r\nfunction getShader( gl: WebGLRenderingContext,\r\n                    source: string,\r\n                    vertexOrFragment: boolean ): WebGLShader\r\n{\r\n  let shader: WebGLShader;\r\n\r\n  shader = vertexOrFragment?\r\n    gl.createShader(gl.VERTEX_SHADER) : gl.createShader(gl.FRAGMENT_SHADER);\r\n\r\n  gl.shaderSource(shader, source);\r\n  gl.compileShader(shader);\r\n  if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n    console.error('Shader failed to compile: '+ gl.getShaderInfoLog(shader));\r\n    return null;\r\n  }\r\n\r\n  return shader;\r\n}\r\n\r\n/****************************************************/\r\n\r\n/*\r\n* Shader module contains shader source and methods to compile/attach shaders\r\n*\r\n* @function initShaders\r\n*/\r\nfunction initShaders(gl: WebGLRenderingContext): WebGLProgram {\r\n  let vertexShader: WebGLShader;\r\n  let fragmentShader: WebGLShader;\r\n  let shaderProgram: WebGLProgram;\r\n\r\n  vertexShader = getShader(gl, VERTEX_SHADER, true);\r\n  fragmentShader = getShader(gl, FRAGMENT_SHADER, false);\r\n  if(vertexShader === null || fragmentShader === null) {\r\n    console.log(\"Shader failed to compile. See error message for details.\");\r\n    return null;\r\n  }\r\n\r\n  shaderProgram = gl.createProgram();\r\n  gl.attachShader(shaderProgram, vertexShader);\r\n  gl.attachShader(shaderProgram, fragmentShader);\r\n  gl.linkProgram(shaderProgram);\r\n  if( !gl.getProgramParameter(shaderProgram, gl.LINK_STATUS) ) {\r\n    console.error(\"Could not initialize shader program.\");\r\n    return null;\r\n  }\r\n  gl.useProgram(shaderProgram);\r\n\r\n  return shaderProgram;\r\n}\r\n\r\n/************************************************************************/\r\n\r\n// Export initShaders from this program\r\n\r\nexport default initShaders;\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Shaders.ts\n **/","/*\r\n\r\nWebGL Raytracer\r\n---------------\r\n\r\nLight object:\r\n- contains information that will be passed to the GPU for each light source\r\n\r\n*/\r\n\r\nimport Vector from \"./Vector\";\r\n\r\n/*\r\n* Interface for the argument of the object's constructor\r\n* contains params for the object\r\n*\r\n* @interface LightParams\r\n*/\r\nexport interface LightParams {\r\n  pos: Vector;\r\n  color: Vector;\r\n  intensity: number;\r\n}\r\n\r\n/*\r\n* This class will send info about a light source to the GPU\r\n*\r\n* @class Light\r\n*/\r\nexport default class Light {\r\n  public position: Vector;\r\n  public color: Vector;\r\n  public intensity: number;\r\n\r\n  constructor(params: LightParams) {\r\n    this.position = params.pos;\r\n    this.color = params.color;\r\n    this.intensity = params.intensity;\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Light.ts\n **/","/*\r\n\r\nWebGL Raytracer\r\n---------------\r\n\r\nSphere object:\r\n- contains information that will be passed to the GPU for each sphere object\r\n\r\n*/\r\n\r\nimport Vector from \"./Vector\";\r\n\r\n/*\r\n* Parameters for the sphere constructor\r\n*\r\n* @interface SphereParams\r\n*/\r\nexport interface SphereParams {\r\n  pos: Vector;\r\n  radius: number;\r\n  diffuse: Vector;\r\n  specular?: Vector;\r\n  shininess?: number;\r\n  reflectivity?: number;\r\n  refractiveIndex?: number;\r\n  opacity?: number;\r\n}\r\n\r\n/*\r\n* Sphere object\r\n*\r\n* @class Sphere\r\n*/\r\nexport default class Sphere {\r\n  public position: Vector;\r\n  public radius: number;\r\n  public diffuse: Vector;\r\n  public specular: Vector;\r\n  public shininess: number;\r\n  public reflectivity: number;\r\n  public refractiveIndex: number;\r\n  public opacity: number;\r\n\r\n  constructor(params: SphereParams) {\r\n    this.position = params.pos;\r\n    this.radius = params.radius;\r\n    this.diffuse = params.diffuse;\r\n    this.specular = params.specular === undefined?\r\n      new Vector(0.9, 0.9, 0.9) : params.specular;\r\n    this.shininess = params.shininess === undefined?\r\n     250 : params.shininess;\r\n    this.refractiveIndex = params.refractiveIndex === undefined?\r\n      1.4 : params.refractiveIndex;\r\n    this.opacity = params.opacity === undefined?\r\n      1 : params.opacity\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Sphere.ts\n **/"],"sourceRoot":""}