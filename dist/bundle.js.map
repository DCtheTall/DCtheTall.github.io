{"version":3,"sources":["webpack:///webpack/bootstrap 2c7b7be6c4b7187e9fcb","webpack:///./ts/main.ts","webpack:///./ts/Raytracer.ts","webpack:///./ts/Vector.ts","webpack:///./ts/Quaternion.ts","webpack:///./ts/Camera.ts","webpack:///./ts/Shaders.ts","webpack:///./ts/Light.ts","webpack:///./ts/Sphere.ts"],"names":[],"mappings":"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","file":"./dist/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 2c7b7be6c4b7187e9fcb\n **/","/*\n\nWebGL TypeScript Raytracer\n--------------------------\nAuthor: Dylan Cutler\n--------------------\n\nMain program\n\n*/\n\nimport Raytracer from \"./Raytracer\";\nimport Vector from \"./Vector\";\nimport Light from \"./Light\";\nimport Sphere from \"./Sphere\";\n\nfunction main(): void {\n  let canvas: HTMLCanvasElement;\n  let raytracer: Raytracer;\n\n  canvas = document.createElement(\"canvas\");\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n  canvas.style.position = 'fixed'\n  canvas.style.left = '0px'; canvas.style.top = '0px';\n  document.body.appendChild(canvas);\n  raytracer = new Raytracer(canvas);\n  initStaticScene(raytracer);\n}\n\nwindow.onload = (event: Event): void => main();\n\n/***** Create animated scene *****/\n\nfunction initAnimatedScene(raytracer: Raytracer) {\n  raytracer.setLookAt(-1, 2, 15, 0, 5, 0);\n  raytracer.Animate = true;\n  raytracer.lights.push(\n    new Light({ pos: new Vector(0, 8, 8), color: new Vector(0.3, 0.5, 0.3), intensity: 10 }),\n    new Light({ pos: new Vector(6, 5, 10), color: new Vector(1, 0.7, 0.5), intensity: 10 }),\n    new Light({ pos: new Vector(-5, 1, 2), color: new Vector(0.5, 0.5, 1), intensity: 8 })\n  );\n  raytracer.spheres.push(\n    new Sphere({\n      pos: new Vector(0, 0.7, 0),\n      diffuse: new Vector(0.9, 0.5, 0.3),\n      specular: new Vector(1, 1, 1),\n      radius: 0.5,\n      shininess: 500,\n      refractiveIndex: 2.6,\n      opacity: 0.7\n    }),\n    new Sphere({\n      pos: new Vector(0.6, 0.7, 0),\n      diffuse: new Vector(0.7, 0.3, 0.3),\n      specular: new Vector(1, 1, 1),\n      radius: 0.07,\n      shininess: 500,\n      refractiveIndex: 2.4,\n      opacity: 0.8\n    }),\n    new Sphere({\n      pos: new Vector(1.3, 0.7, 0),\n      diffuse: new Vector(0.3, 0.6, 0.8),\n      specular: new Vector(1, 1, 1),\n      radius: 0.15,\n      shininess: 500,\n      refractiveIndex: 2.5,\n      opacity: 0.7\n    }),\n    new Sphere({\n      pos: new Vector(1.32, 0.9, 0),\n      diffuse: new Vector(1, 1, 1),\n      specular: new Vector(1, 1, 1),\n      radius: 0.04,\n      shininess: 500,\n      refractiveIndex: 2.5,\n      opacity: 0.6\n    }),\n    new Sphere({\n      pos: new Vector(1.75, 0, 0),\n      diffuse: new Vector(0.3, 0.3, 1),\n      specular: new Vector(1, 1, 1),\n      radius: 0.3,\n      refractiveIndex: 2.4,\n      opacity: 0.4\n    })\n  )\n\n  function animate(raytracer: Raytracer): void {\n    let time: number;\n    let pos1: Vector;\n    let pos2: Vector;\n    let pos3: Vector;\n    let pos4: Vector;\n    time = new Date().getTime();\n    pos1 = new Vector(0.7, 0.7, 0);\n    pos1 = Vector.rotate(pos1, time/723, new Vector(0, 1, 0));\n    raytracer.spheres[1].position = pos1;\n    pos2 = new Vector(1, 0.7, 0);\n    pos2 = Vector.rotate(pos2, time/1000, new Vector(0, 1, 0));\n    raytracer.spheres[2].position = pos2;\n    pos3 = new Vector(-0.3, 0.15, 0);\n    pos3 = Vector.rotate(pos3, time/600, new Vector(1, 2, 0));\n    pos3 = Vector.add(pos2, pos3);\n    raytracer.spheres[3].position = pos3;\n    pos4 = new Vector(1.75, 0.7, 0);\n    pos4 = Vector.rotate(pos4, time/1870, new Vector(0, 1, 0));\n    raytracer.spheres[4].position = pos4;\n  }\n  setTimeout(() => { raytracer.render(animate) }, 100);\n}\n\n\n/***** Create static scene *****/\n\nfunction initStaticScene(raytracer: Raytracer) {\n  raytracer.setLookAt(-1, 2, 15, 0, 5, 0);\n  raytracer.Animate = false;\n  raytracer.lights.push(\n    new Light({ pos: new Vector(0, 8, 8), color: new Vector(0.3, 0.5, 0.3), intensity: 10 }),\n    new Light({ pos: new Vector(6, 5, 10), color: new Vector(1, 0.7, 0.5), intensity: 10 }),\n    new Light({ pos: new Vector(-5, 1, 2), color: new Vector(0.5, 0.5, 1), intensity: 8 })\n  );\n  raytracer.spheres.push(\n    new Sphere({\n      pos: new Vector(0.5, 0.5, 1.5),\n      diffuse: new Vector(0.3, 0.5, 0.7),\n      specular: new Vector(1, 1, 1),\n      radius: 0.3,\n      shininess: 500,\n      refractiveIndex: 2.6,\n      opacity: 0.5\n    }),\n    new Sphere({\n      pos: new Vector(-0.3, 0.5, -1),\n      diffuse: new Vector(1, 0.5, 0.3),\n      radius: 0.5,\n      shininess: 50,\n      refractiveIndex: 2.4,\n      opacity: 0.8\n    }),\n    new Sphere({\n      pos: new Vector(1.75, 0.8, -5),\n      diffuse: new Vector(0.3, 0.7, 0.3),\n      specular: new Vector(1, 1, 1),\n      radius: 0.8,\n      shininess: 500,\n      refractiveIndex: 2,\n      opacity: 0.4\n    }),\n    new Sphere({\n      pos: new Vector(-0.8, 1, 4),\n      diffuse: new Vector(1, 1, 1),\n      radius: 0.2,\n      shininess: 1000,\n      refractiveIndex: 2.6,\n      opacity: 0.3\n    })\n  );\n\n  setTimeout(() => { raytracer.render(); }, 100);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/main.ts\n **/","/*\n\nWebGL Raytracer\n---------------\n\nScene object:\n- Initializes instance of WebGL\n- Calls functions for WebGL to render\n- Initializes the shaders using initShaders()\n- Sends information about the camera to the GPU\n- Renders the scene\n\n*/\n\nimport Vector from \"./Vector\";\nimport Camera from \"./Camera\";\nimport initShaders from \"./Shaders\";\nimport Light from \"./Light\";\nimport Sphere from \"./Sphere\";\n\nexport default class Raytracer {\n\n  private ASPECT_RATIO: number;\n  private gl: WebGLRenderingContext;\n  private shaderProgram: WebGLProgram;\n  private camera: Camera;\n\n  public lights: Light[];\n  public spheres: Sphere[];\n  public Animate: boolean;\n\n  /*\n  * @class Raytracer\n  * @constructor\n  */\n  constructor(canvas: HTMLCanvasElement) {\n    this.ASPECT_RATIO = canvas.width / canvas.height;\n    // Initialzing WebGL\n    this.gl = <WebGLRenderingContext>\n      canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n    this.gl.viewport(0, 0, canvas.width, canvas.height);\n    this.gl.clearColor(0, 0, 0, 1);\n    this.gl.clearDepth(1);\n    // Initializing shaders\n    this.shaderProgram = initShaders(this.gl);\n    if( this.shaderProgram === null ) {\n      throw new Error(\"Could not compile shaders. See error message for details.\");\n    }\n    // Initializing buffers\n    this.initBuffers();\n    // Setting camera to null\n    this.camera = null;\n    // Initializing lights array\n    this.lights = [];\n    // Initializing spheres array\n    this.spheres = [];\n    // Initializing flag for whether the raytracer animates\n    this.Animate = false;\n  }\n\n  /*\n  * This method initializes the vertex buffers, input is aspect ratio\n  *\n  * @class Raytracer\n  * @method initBuffers\n  */\n  private initBuffers(): void {\n    let aWindowPosition: number;\n    let aPosition: number;\n    let vertices: number[];\n    let windowBuffer: WebGLBuffer;\n    let positionBuffer: WebGLBuffer;\n\n    // Buffer for the vertices of the window\n    aWindowPosition = this.gl.getAttribLocation(this.shaderProgram, 'aWindowPosition');\n    this.gl.enableVertexAttribArray(aWindowPosition);\n\n    aPosition = this.gl.getAttribLocation(this.shaderProgram, 'aPosition');\n    this.gl.enableVertexAttribArray(aPosition);\n\n    vertices = [\n      -1., 1.,\n      -1., -1.,\n      1., 1.,\n      1., -1.\n    ];\n\n    windowBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, windowBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, windowBuffer);\n    this.gl.vertexAttribPointer(aWindowPosition, 2, this.gl.FLOAT, false, 0, 0);\n\n    positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n    this.gl.vertexAttribPointer(aPosition, 3, this.gl.FLOAT, false, 0, 0);\n  }\n\n  /*\n  * This method sets position and lookAt vectors of the camera\n  *\n  * @class Raycaster\n  * @method setLookAt\n  */\n  public setLookAt( eyeX: number, eyeY: number, eyeZ: number,\n                     atX: number,  atY: number,  atZ: number ): void\n  {\n    this.camera = new Camera(new Vector(eyeX, eyeY, eyeZ),\n                             new Vector( atX,  atY,  atZ));\n  }\n\n  /*\n  * This method renders the scene in WebGL\n  *\n  * @class Raycaster\n  * @method render\n  */\n  public render(animate?: (raytracer: Raytracer) => void): void {\n    // Executes callback for each draw\n    if(animate) animate(this);\n\n    const AspRat: number = this.ASPECT_RATIO;\n    let cameraPosition: WebGLUniformLocation;\n    let lightUniform: WebGLUniformLocation;\n    let sphereUniform: WebGLUniformLocation;\n    let cameraTopLeft: Vector;\n    let cameraBottomLeft: Vector;\n    let cameraTopRight: Vector;\n    let cameraBottomRight: Vector;\n    let corners: number[];\n    let aPosition: number;\n\n    // Clear last rendered frame\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n\n    // Passing camera position to the shader\n    cameraPosition = this.gl.getUniformLocation(this.shaderProgram, 'cameraPos');\n    this.gl.uniform3fv(cameraPosition, new Float32Array(Vector.push(this.camera.pos, [])));\n\n    // Passing lights to the shader\n    lightUniform = this.gl.getUniformLocation(this.shaderProgram, 'numLights');\n    this.gl.uniform1i(lightUniform, this.lights.length);\n    this.lights.map((currLight: Light, index: number) => {\n      // Sending positions\n      lightUniform = this.gl.getUniformLocation(this.shaderProgram, 'lightPos['+index+']');\n      this.gl.uniform3fv(lightUniform, new Float32Array(Vector.push(currLight.position, [])));\n      // Sending colors\n      lightUniform = this.gl.getUniformLocation(this.shaderProgram, 'lightCol['+index+']');\n      this.gl.uniform3fv(lightUniform, new Float32Array(Vector.push(currLight.color, [])));\n      // Sending intensities\n      lightUniform = this.gl.getUniformLocation(this.shaderProgram, 'intensities['+index+']');\n      this.gl.uniform1f(lightUniform, currLight.intensity);\n    });\n\n    // Passing spheres to the shader\n    sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'numSpheres');\n    this.gl.uniform1i(sphereUniform, this.spheres.length);\n    this.spheres.map((currSphere: Sphere, index: number) => {\n      // Sending positions\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'spherePos['+index+']');\n      this.gl.uniform3fv(sphereUniform, new Float32Array(Vector.push(currSphere.position, [])));\n      // Sending radius of sphere\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereRadius['+index+']');\n      this.gl.uniform1f(sphereUniform, currSphere.radius);\n      // Sending diffuse colors\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereDiff['+index+']');\n      this.gl.uniform3fv(sphereUniform, new Float32Array(Vector.push(currSphere.diffuse, [])));\n      // Sending specular colors\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereSpec['+index+']');\n      this.gl.uniform3fv(sphereUniform, new Float32Array(Vector.push(currSphere.specular, [])));\n      // Sending Phong exponent to the shader\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereShininess['+index+']');\n      this.gl.uniform1f(sphereUniform, currSphere.shininess);\n      // Sending refractive index to the shader\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereRefrIndex['+index+']');\n      this.gl.uniform1f(sphereUniform, currSphere.refractiveIndex);\n      // Sending sphere's opacity to the shader\n      sphereUniform = this.gl.getUniformLocation(this.shaderProgram, 'sphereOpacity['+index+']');\n      this.gl.uniform1f(sphereUniform, currSphere.opacity);\n    });\n\n    // Get camera corners\n    corners = [];\n    cameraTopLeft = Vector.add(\n      this.camera.forward,\n      Vector.subtract(this.camera.up, Vector.scale(AspRat, this.camera.right))\n    );\n    cameraBottomLeft = Vector.subtract(\n      this.camera.forward,\n      Vector.add(this.camera.up, Vector.scale(AspRat, this.camera.right))\n    );\n    cameraTopRight = Vector.add(\n      this.camera.forward,\n      Vector.add(this.camera.up, Vector.scale(AspRat, this.camera.right))\n    );\n    cameraBottomRight = Vector.add(\n      this.camera.forward,\n      Vector.subtract(Vector.scale(AspRat, this.camera.right), this.camera.up)\n    );\n    Vector.push(cameraTopLeft, corners);\n    Vector.push(cameraBottomLeft, corners);\n    Vector.push(cameraTopRight, corners);\n    Vector.push(cameraBottomRight, corners);\n\n    // Passing corners to the shader via the array buffer\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(corners), this.gl.STATIC_DRAW);\n\n    // Draw new frame\n    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n\n    // Render loop\n    if( this.Animate ) window.requestAnimationFrame(() => { this.render(animate); });\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Raytracer.ts\n **/","/*\n\nWebGL Raytracer\n---------------\n\nVector object\n- vector operations\n- push components to an array\n\n*/\n\nimport Quaternion from \"./Quaternion\";\n\nexport default class Vector {\n  constructor(public x: number,\n              public y: number,\n              public z: number) {}\n\n  public set(x: number, y: number, z: number) {\n    this.x = x; this.y = y; this.z = z;\n  }\n\n  static scale(k: number, v: Vector): Vector {\n    return new Vector(k*v.x, k*v.y, k*v.z)\n  }\n  static add(v1: Vector, v2: Vector): Vector {\n    return new Vector(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);\n  }\n  static subtract(v1: Vector, v2: Vector): Vector {\n    return new Vector(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);\n  }\n  static mag(v: Vector): number {\n    return Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);\n  }\n  static normalize(v: Vector): Vector {\n    let mag: number;\n    let div: number;\n    mag = Vector.mag(v);\n    if(mag === 0) {\n      console.log('Cannot normalize zero vector');\n      return null;\n    }\n    div = 1/mag;\n    return Vector.scale(div, v);\n  }\n  static cross(v1: Vector, v2: Vector): Vector {\n    return new Vector(v1.y * v2.z - v1.z * v2.y,\n                      v1.z * v2.x - v1.x * v2.z,\n                      v1.x * v2.y - v1.y * v2.x);\n  }\n  static rotate(v: Vector, theta: number, axis: Vector): Vector {\n    let p: Quaternion;\n    let u: Vector;\n    let q: Quaternion;\n    p = new Quaternion(0, v.x, v.y, v.z);\n    u = Vector.scale(Math.sin(theta / 2), Vector.normalize(axis));\n    q = new Quaternion(Math.cos(theta / 2), u.x, u.y, u.z);\n    p = Quaternion.multiply(p, q.conjugate());\n    p = Quaternion.multiply(q, p);\n    return new Vector(p.i, p.j, p.k);\n  }\n  static push(v: Vector, array: number[]): number[] {\n    array.push(v.x, v.y, v.z);\n    return array;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Vector.ts\n **/","/*\n\nWebGL Raytacer\n--------------\n\nQuaternion object\n- Contains mathematical operations for quaternions\n\n*/\n\nexport default class Quaternion {\n  constructor( public r: number,\n               public i: number,\n               public j: number,\n               public k: number ) {}\n  public conjugate(): Quaternion {\n    return new Quaternion(this.r, -this.i, -this.j, -this.k);\n  }\n  static multiply(q1: Quaternion, q2: Quaternion): Quaternion {\n    return new Quaternion( q1.r*q1.r - q1.i*q2.i - q1.j*q2.j - q1.k*q2.k,\n                           q1.r*q2.i + q1.i*q2.r + q1.j*q2.k - q1.k*q2.j,\n                           q1.r*q2.j - q1.i*q2.k + q1.j*q2.r + q1.k*q2.i,\n                           q1.r*q2.k + q1.i*q2.j - q1.j*q2.i + q1.k*q2.r );\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Quaternion.ts\n **/","/*\n\nWebGL Raytracer\n---------------\n\nCamera object:\n- has public vector classes for raytracer\n\n*/\n\nimport Vector from \"./Vector\";\n\nexport default class Camera {\n  public forward: Vector;\n  public right: Vector;\n  public up: Vector;\n\n  constructor(public pos: Vector, lookAt: Vector) {\n    let down: Vector;\n    down = new Vector(0, -1, 0);\n    this.forward = Vector.normalize(Vector.subtract(lookAt, this.pos));\n    this.right = Vector.normalize(Vector.cross(down, this.forward));\n    this.up = Vector.normalize(Vector.cross(this.right, this.forward));\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Camera.ts\n **/","/*\n\nWebGL Raytracer\n---------------\n\nShaders module:\n- contains source for vertex and fragment shaders\n- contains function to get shader program from source and compiles them\n- exports a function which initializes the shaders and returns the shader\n  program\n\n*/\n\n/****************************************************/\n\n/*\n* SHADER SOURCE CODE\n*/\n\nlet VERTEX_SHADER: string;\nlet FRAGMENT_SHADER: string;\n\n/* VERTEX SHADER */\n\nVERTEX_SHADER = `\n  precision mediump float;\n\n  attribute vec2 aWindowPosition;\n  attribute vec3 aPosition;\n\n  varying vec3 vPosition;\n\n  void main() {\n    gl_Position = vec4(aWindowPosition, 1., 1.);\n    vPosition = aPosition;\n  }\n`;\n\n/* FRAGMENT SHADER */\n\nFRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec3 vPosition;\n\n  uniform vec3 cameraPos;\n  uniform int numLights;\n  uniform vec3 lightPos[32];\n  uniform vec3 lightCol[32];\n  uniform float intensities[32];\n  uniform int numSpheres;\n  uniform vec3 spherePos[32];\n  uniform float sphereRadius[32];\n  uniform vec3 sphereDiff[32];\n  uniform vec3 sphereSpec[32];\n  uniform float sphereShininess[32];\n  uniform float sphereRefrIndex[32];\n  uniform float sphereOpacity[32];\n\n  const int numReflections = 3;\n\n  /***** INTERSECTION TESTS FOR GEOMETRIES *****/\n\n  /**\n  * Intersection test for a plane at y = 0\n  */\n  float intersectPlane(vec3 rayStart, vec3 rayDir) {\n    float dist;\n    float denom;\n\n    dist = -1.;\n    denom = dot(rayDir, vec3(0., 1., 0.));\n    if( denom < 0. ) {\n      dist = dot(-rayStart, vec3(0., 1., 0.)) / denom;\n    }\n\n    return dist;\n  }\n\n  /**\n  * Intersection test for spheres\n  */\n  float intersectSphere(vec3 rayStart, vec3 rayDir, vec3 center, float r) {\n    vec3 at;\n    float v;\n    float dist;\n    float disc;\n\n    at = center - rayStart;\n    v = dot(at, rayDir);\n    dist = -1.;\n    if( v >= 0. ) {\n      disc = r * r - ( dot(at, at) - v * v );\n      if( disc > 0. ) dist = v - sqrt(disc);\n    }\n    return dist;\n  }\n\n  /***** OPTICAL FUNCTIONS *****/\n\n  /**\n  * Test for shadow casting implements pyramid tracing to soften shadow edges\n  */\n  void testForShadow( inout bool inShadow[4],\n                        float distanceToLight,\n                        vec3 rayStart,\n                        vec3 rayDir,\n                        vec3 normal )\n  {\n    vec3 dx;\n    vec3 dy;\n    float r;\n\n    dx = cross(normal, rayDir);\n    if( length(dx) != 0. ) dx = normalize(dx);\n    dy = cross(rayDir, dx);\n    if( length(dy) != 0. ) dy = normalize(dy);\n    r = 0.01;\n\n    for( int j = 0; j < 4; j++ )\n    for( int i = 0; i < 32; i++ ) {\n      if( i >= numSpheres ) continue;\n\n      vec3 ds;\n      float dist;\n\n      if( j == 0 ){ ds = -dx - dy; }\n      else if( j == 1 ){ ds = dx - dy; }\n      else if( j == 2 ){ ds = dy - dx; }\n      else { ds = dy + dx; }\n      ds = r * normalize(ds);\n\n      dist = intersectSphere(rayStart, normalize(rayDir + ds), spherePos[i], sphereRadius[i]);\n      if( dist > 0. && dist < distanceToLight ) inShadow[j] = true;\n    }\n  }\n\n  /**\n  * Determine the reflectance of the sphere using its refractive index\n  * and the Fresnel equations\n  */\n  float determineReflectance(vec3 normal, vec3 rayDir, float refrIndex) {\n    float cosine_i;\n    float sine_i;\n    float theta_t;\n    float cosine_t;\n    float refl;\n\n    /* Snell's law to find the angle the transmitted ray makes with the normal */\n    cosine_i = dot(normalize(normal), normalize(-rayDir));\n    sine_i = length(cross( normalize(normal), normalize(-rayDir) ));\n    theta_t = asin( sine_i / refrIndex );\n    cosine_t = cos(theta_t);\n\n    /* Finding reflectance with Fresnel's equations */\n    refl = cosine_i - refrIndex * cosine_t;\n    refl /= cosine_i + refrIndex * cosine_t;\n    refl = pow(abs(refl), 2.);\n\n    return clamp(refl, 0., 1.);\n  }\n\n  /**\n  * Determine the direction of the transmitted light ray\n  */\n  void transmitRay( vec3 rayStart,\n                    vec3 rayDir,\n                    vec3 opticalAxis,\n                    float refrIndex,\n                    float radius,\n                    out vec3 outStart,\n                    out vec3 outDir )\n  {\n    vec3 normalAxis;\n    vec2 opticalVec;\n    mat2 Refr_1;\n    mat2 Refr_2;\n\n    /* Determining normal axis */\n    normalAxis = rayDir - (dot(rayDir, -opticalAxis) * opticalAxis);\n    if( length(normalAxis) != 0. ) normalAxis = normalize(normalAxis);\n\n    /* Defining quantities for matrix ray tracing */\n    opticalVec = vec2( 0., acos(dot(opticalAxis, -rayDir)) );\n    Refr_1 = mat2( 1., (1. - refrIndex)/(radius * refrIndex), 0., 1./refrIndex );\n    Refr_2 = mat2( 1., (refrIndex - 1.)/radius, 0., refrIndex );\n\n    /* First refraction */\n    opticalVec = Refr_1 * opticalVec;\n    /* Translation through medium of the sphere */\n    opticalVec.x += sin(opticalVec.y) * 2. * radius;\n\n    /* Determining the starting point of the outgoing ray */\n    outStart = rayStart - (cos(opticalVec.y) * opticalAxis) + (opticalVec.x * normalAxis);\n\n    /* Second refraction */\n    opticalVec = Refr_2 * opticalVec;\n\n    /* Determining the direction of the outgoing ray */\n    outDir = (-cos(opticalVec.y) * opticalAxis) + (sin(opticalVec.y) * normalAxis);\n  }\n\n  /***** COLORING FUNCTIONS *****/\n\n  /**\n  * Color fragment using Blinn-Phong global illumination model\n  */\n  vec3 getNaturalColor( vec3 pos,\n                        vec3 normal,\n                        vec3 viewDir,\n                        vec3 diffColor,\n                        vec3 specColor,\n                        float shininess )\n  {\n    vec3 color = vec3(0.);\n    for ( int i = 0; i < 32; i++ ) {\n      if( i >= numLights ) continue;\n\n      vec3 currPos;\n      vec3 currColor;\n      float intensity;\n      vec3 lightDir;\n      float distance;\n      bool isInShadow[4];\n      float lMax;\n      float sMax;\n      vec3 testColor;\n      float lambertian;\n      vec3 H;\n      float specular;\n\n      lightDir = normalize(lightPos[i] - pos);\n      distance = length(lightPos[i] - pos);\n\n      for( int j = 0; j < 4; j++ ) isInShadow[j] = false;\n      testForShadow(isInShadow, distance, pos, lightDir, normal);\n\n      lMax = 1.; sMax = 1.;\n\n      for( int j = 0; j < 4; j++ ) {\n        if( isInShadow[j] ) {\n          lMax -= 0.2;\n          sMax -= 0.2475;\n        }\n      }\n\n      lambertian = clamp(intensities[i] * dot(normal, lightDir) / distance, 0.0, lMax);\n\n      H = normalize(lightDir + viewDir);\n      specular = clamp(intensities[i] * pow(dot(normal, H), shininess) / distance / distance, 0.01, sMax);\n\n      color += (lambertian * diffColor + specular * specColor) * lightCol[i];\n    }\n    return color;\n  }\n\n  /**\n  * Get refracted color of non-opaque objects\n  */\n  vec3 getRefractedColor(vec3 refrStart, vec3 rayDir, vec3 opticalAxis, float refrIndex, float radius, float opacity) {\n    vec3 color;\n    vec3 rayStart_f;\n    vec3 rayDir_f;\n    float closestDist;\n    float dist;\n    vec3 pos;\n    vec3 normal;\n    vec3 diffCol;\n    vec3 specCol;\n    float phongExp;\n    float refl;\n    float index;\n\n    color = vec3(0.);\n    transmitRay(refrStart, rayDir, opticalAxis, refrIndex, radius, rayStart_f, rayDir_f);\n\n    closestDist = 100000.;\n\n    dist = intersectPlane(rayStart_f, rayDir_f);\n    if( dist > 0. ) {\n      closestDist = dist;\n      pos = dist * rayDir_f + rayStart_f;\n      normal = vec3(0., 1., 0.);\n      if( mod(floor(pos.x) + floor(pos.z), 2.) != 0. ) {\n        diffCol = vec3(0.9);\n        specCol = vec3(1.);\n        refl = determineReflectance(normal, rayDir_f, 1.05);\n      }\n      else {\n        diffCol = vec3(0.2, 0.2, 0.4);\n        specCol = vec3(0.4);\n        refl = determineReflectance(normal, rayDir_f, 1.2);\n      }\n    }\n\n    for( int i = 0; i < 32; i++ ) {\n      if( i >= numSpheres ) continue;\n\n      float distance;\n      distance = intersectSphere(rayStart_f, rayDir_f, spherePos[i], sphereRadius[i]);\n\n      if( distance > 0. && distance < closestDist ) {\n        dist = distance;\n        closestDist = distance;\n        pos = distance * rayDir_f + rayStart_f;\n        normal = normalize(pos - spherePos[i]);\n        diffCol = sphereDiff[i];\n        specCol = sphereSpec[i];\n        phongExp = sphereShininess[i];\n        index = sphereRefrIndex[i];\n        refl = determineReflectance(normal, rayDir_f, index);\n      }\n    }\n\n    if( dist > 0. ) {\n      color = getNaturalColor(pos, normal, -rayDir_f, diffCol, specCol, phongExp);\n      color *= opacity;\n    }\n\n    return color;\n  }\n\n  /**\n  * Get reflected color\n  */\n  vec3 getReflectedColor(vec3 reflStart, vec3 reflNormal, vec3 rayDir, float refl) {\n    const int MAX_DEPTH = 2;\n\n    vec3 color;\n    float closestDist;\n    vec3 reflDir;\n    float dist;\n    vec3 pos;\n    vec3 normal;\n    vec3 diffCol;\n    vec3 specCol;\n    float phongExp;\n    float opacity;\n    float index;\n    float radius;\n\n    color = vec3(0.);\n\n    for( int i = 0; i <= MAX_DEPTH; i++ ) {\n      float thisRefl = 1.;\n\n      closestDist = 100000.;\n      reflDir = reflect(rayDir, reflNormal);\n\n      dist = intersectPlane(reflStart, reflDir);\n      if( dist > 0. ) {\n        closestDist = dist;\n        pos = dist * reflDir + reflStart;\n        normal = vec3(0., 1., 0.);\n        if( mod(floor(pos.x) + floor(pos.z), 2.) != 0. ) {\n          diffCol = vec3(0.9);\n          specCol = vec3(1.);\n          if( i != 0 ) thisRefl = determineReflectance(normal, rayDir, 1.2);\n        }\n        else {\n          diffCol = vec3(0.4, 0.4, 0.6);\n          specCol = vec3(0.6);\n          if( i != 0 ) thisRefl = determineReflectance(normal, rayDir, 1.7);\n        }\n        phongExp = 250.;\n        opacity = 1.;\n      }\n\n      for( int i = 0; i < 32; i++ ) {\n        if( i >= numSpheres ) continue;\n\n        float distance;\n        distance = intersectSphere(reflStart, reflDir, spherePos[i], sphereRadius[i]);\n        if( distance >= 0. && distance < closestDist ) {\n          dist = distance;\n          closestDist = dist;\n          pos = dist * reflDir + reflStart;\n          normal = normalize(pos - spherePos[i]);\n          diffCol = sphereDiff[i];\n          specCol = sphereSpec[i];\n          phongExp = sphereShininess[i];\n          index = sphereRefrIndex[i];\n          if( i != 0 ) determineReflectance(normal, rayDir, index);\n          opacity = sphereOpacity[i];\n          radius = sphereRadius[i];\n        }\n      }\n\n      if( dist > 0. ) {\n        vec3 c = getNaturalColor(pos, normal, -reflDir, diffCol, specCol, phongExp);\n        refl *= thisRefl;\n        color += pow(refl, float(i+1)) * c;\n        if( opacity != 1. ) {\n          color *= opacity;\n          vec3 refrCol;\n          refrCol = getRefractedColor(pos, -reflDir, normal, index, radius, opacity);\n          refrCol *= 1. - opacity;\n          color += refrCol;\n        }\n\n        reflStart = pos;\n        reflNormal = normal;\n        rayDir = reflDir;\n      }\n      else break;\n    }\n\n    return color;\n  }\n\n  /***** MAIN PROGRAM *****/\n\n  /**\n  * Intersection test for the world\n  * returns a color vector\n  */\n  vec3 intersectWorld(vec3 rayStart, vec3 rayDir) {\n    vec3 color;\n    float closestDist;\n    float dist;\n    vec3 pos;\n    vec3 normal;\n    vec3 diffCol;\n    vec3 specCol;\n    float phongExp;\n    float refl;\n    float opacity;\n    float index;\n    float radius;\n\n\n    color = vec3(0.);\n    closestDist = 100000.;\n\n    dist = intersectPlane(rayStart, rayDir);\n    if( dist > 0. ) {\n      closestDist = dist;\n      pos = dist * rayDir + rayStart;\n      normal = vec3(0., 1., 0.);\n      if( mod(floor(pos.x) + floor(pos.z), 2.) != 0. ) {\n        diffCol = vec3(0.9);\n        specCol = vec3(1.);\n        refl = determineReflectance(normal, rayDir, 1.05);\n      }\n      else {\n        diffCol = vec3(0.2, 0.2, 0.4);\n        specCol = vec3(0.4);\n        refl = determineReflectance(normal, rayDir, 1.2);\n      }\n      phongExp = 250.;\n      opacity = 1.;\n    }\n\n    for( int i = 0; i < 32; i++ ) {\n      if( i >= numSpheres ) continue;\n\n      float distance;\n      distance = intersectSphere(rayStart, rayDir, spherePos[i], sphereRadius[i]);\n\n      if( distance > 0. && distance < closestDist ) {\n        dist = distance;\n        closestDist = distance;\n        pos = distance * rayDir + rayStart;\n        normal = normalize(pos - spherePos[i]);\n        diffCol = sphereDiff[i];\n        specCol = sphereSpec[i];\n        phongExp = sphereShininess[i];\n        index = sphereRefrIndex[i];\n        refl = determineReflectance(normal, rayDir, index);\n        opacity = sphereOpacity[i];\n        radius = sphereRadius[i];\n      }\n    }\n\n    if( dist > 0. ) {\n      color = getNaturalColor(pos, normal, -rayDir, diffCol, specCol, phongExp);\n      if( opacity != 1. ) {\n        color *= opacity;\n        vec3 refrCol;\n        refrCol = getRefractedColor(pos, rayDir, normal, index, radius, opacity);\n        refrCol *= 1. - opacity;\n        color += refrCol;\n      }\n      color += getReflectedColor(pos, normal, rayDir, refl);\n    }\n\n    return color;\n  }\n\n  /**\n  * Main function, just determines the direction of the initial ray and\n  * calls intersectWorld()\n  */\n  void main() {\n    vec3 cameraDir;\n    vec3 color;\n\n    cameraDir = normalize(vPosition - cameraPos);\n    color = intersectWorld(cameraPos, cameraDir);\n\n    gl_FragColor = vec4(color, 1.);\n  }\n`;\n\n/****************************************************/\n\n/*\n* This function loads the shader from the source code\n*/\nfunction getShader( gl: WebGLRenderingContext,\n                    source: string,\n                    vertexOrFragment: boolean ): WebGLShader\n{\n  let shader: WebGLShader;\n\n  shader = vertexOrFragment?\n    gl.createShader(gl.VERTEX_SHADER) : gl.createShader(gl.FRAGMENT_SHADER);\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error('Shader failed to compile: '+ gl.getShaderInfoLog(shader));\n    return null;\n  }\n\n  return shader;\n}\n\n/****************************************************/\n\n/*\n* Shader module contains shader source and methods to compile/attach shaders\n*\n* @function initShaders\n*/\nfunction initShaders(gl: WebGLRenderingContext): WebGLProgram {\n  let vertexShader: WebGLShader;\n  let fragmentShader: WebGLShader;\n  let shaderProgram: WebGLProgram;\n\n  vertexShader = getShader(gl, VERTEX_SHADER, true);\n  fragmentShader = getShader(gl, FRAGMENT_SHADER, false);\n  if(vertexShader === null || fragmentShader === null) {\n    console.log(\"Shader failed to compile. See error message for details.\");\n    return null;\n  }\n\n  shaderProgram = gl.createProgram();\n  gl.attachShader(shaderProgram, vertexShader);\n  gl.attachShader(shaderProgram, fragmentShader);\n  gl.linkProgram(shaderProgram);\n  if( !gl.getProgramParameter(shaderProgram, gl.LINK_STATUS) ) {\n    console.error(\"Could not initialize shader program.\");\n    return null;\n  }\n  gl.useProgram(shaderProgram);\n\n  return shaderProgram;\n}\n\n/************************************************************************/\n\n// Export initShaders from this program\n\nexport default initShaders;\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Shaders.ts\n **/","/*\n\nWebGL Raytracer\n---------------\n\nLight object:\n- contains information that will be passed to the GPU for each light source\n\n*/\n\nimport Vector from \"./Vector\";\n\n/*\n* Interface for the argument of the object's constructor\n* contains params for the object\n*\n* @interface LightParams\n*/\nexport interface LightParams {\n  pos: Vector;\n  color: Vector;\n  intensity: number;\n}\n\n/*\n* This class will send info about a light source to the GPU\n*\n* @class Light\n*/\nexport default class Light {\n  public position: Vector;\n  public color: Vector;\n  public intensity: number;\n\n  constructor(params: LightParams) {\n    this.position = params.pos;\n    this.color = params.color;\n    this.intensity = params.intensity;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Light.ts\n **/","/*\n\nWebGL Raytracer\n---------------\n\nSphere object:\n- contains information that will be passed to the GPU for each sphere object\n\n*/\n\nimport Vector from \"./Vector\";\n\n/*\n* Parameters for the sphere constructor\n*\n* @interface SphereParams\n*/\nexport interface SphereParams {\n  pos: Vector;\n  radius: number;\n  diffuse: Vector;\n  specular?: Vector;\n  shininess?: number;\n  reflectivity?: number;\n  refractiveIndex?: number;\n  opacity?: number;\n}\n\n/*\n* Sphere object\n*\n* @class Sphere\n*/\nexport default class Sphere {\n  public position: Vector;\n  public radius: number;\n  public diffuse: Vector;\n  public specular: Vector;\n  public shininess: number;\n  public reflectivity: number;\n  public refractiveIndex: number;\n  public opacity: number;\n\n  constructor(params: SphereParams) {\n    this.position = params.pos;\n    this.radius = params.radius;\n    this.diffuse = params.diffuse;\n    this.specular = params.specular === undefined?\n      new Vector(0.9, 0.9, 0.9) : params.specular;\n    this.shininess = params.shininess === undefined?\n     250 : params.shininess;\n    this.refractiveIndex = params.refractiveIndex === undefined?\n      1.4 : params.refractiveIndex;\n    this.opacity = params.opacity === undefined?\n      1 : params.opacity\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/Sphere.ts\n **/"],"sourceRoot":""}